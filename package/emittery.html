<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>TrustSECO</title><link rel="icon" href="/favicon.ico"/><link rel="preload" href="/TrustSECO/_next/static/css/dd46eff8b0fa29b7c6a1.css" as="style"/><link rel="stylesheet" href="/TrustSECO/_next/static/css/dd46eff8b0fa29b7c6a1.css" data-n-g=""/><link rel="preload" href="/TrustSECO/_next/static/css/9e26edf5045646c35bf5.css" as="style"/><link rel="stylesheet" href="/TrustSECO/_next/static/css/9e26edf5045646c35bf5.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/TrustSECO/_next/static/chunks/main-06c1dcca274dd3ebd367.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/framework.490e6e89fb7343c23de5.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/commons.e12371422b04e39d225f.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/pages/_app-6332075865a73fbac0f6.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/20d867a918a78c19a392d2ab3562d7e5efc3a8e7.a2788434e14b577a5942.js" as="script"/><link rel="preload" href="/TrustSECO/_next/static/chunks/pages/package/%5Bid%5D-7bbdc45fafc792b9b77c.js" as="script"/></head><body><div id="__next"><div class="Home_wrapper__3EDsh"><div class="Home_container__1EcsU"><div class="container"><div class="Home_content__2fqOz row"><a href="/TrustSECO"><h2>TrustSECO</h2></a><div offset="2" class="Home_contentInside__3OhO7 col-md-10 offset-md-1"><main class="Home_main__1x8gC"><div class="row"><div class="col-md-8"><div class="card"><div class="card-header">emittery</div><div class="card-body"><div class="card-subtitle h6">Simple and modern async event emitter</div><p class="card-text">Repository:<!-- --> <a href="git+https://github.com/sindresorhus/emittery.git">git+https://github.com/sindresorhus/emittery.git</a></p></div></div><div class="card"><div class="card-header">Package versions</div><div class="card-body"><p class="card-text"><div><p>Version: <!-- -->0.1.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->8</p></div><div><p>Version: <!-- -->0.1.1<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->9</p></div><div><p>Version: <!-- -->0.1.2<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->9</p></div><div><p>Version: <!-- -->0.2.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->10</p></div><div><p>Version: <!-- -->0.3.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->9</p></div><div><p>Version: <!-- -->0.4.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->10</p></div><div><p>Version: <!-- -->0.4.1<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->10</p></div><div><p>Version: <!-- -->0.5.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->10</p></div><div><p>Version: <!-- -->0.5.1<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->9</p></div><div><p>Version: <!-- -->0.6.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->14</p></div><div><p>Version: <!-- -->0.7.0<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->19</p></div><div><p>Version: <!-- -->0.7.1<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->18</p></div><div><p>Version: <!-- -->0.7.2<br/><span> <!-- -->  </span> trustscore:<!-- --> <!-- -->21</p></div></p></div></div></div><div class="col-md-4"><div class="card"><div class="card-body"><a href="https://secureseco.github.io/Votingsystem#/">Vote score</a></div> </div><div class="card"><div class="card-header">TrustScore <strong>21</strong></div><div class="card-body"><p class="card-text"><strong>Sourcerank:</strong><div>basic_info_present:<!-- --> <!-- -->1</div><div>repository_present:<!-- --> <!-- -->1</div><div>readme_present:<!-- --> <!-- -->1</div><div>license_present:<!-- --> <!-- -->1</div><div>versions_present:<!-- --> <!-- -->1</div><div>follows_semver:<!-- --> <!-- -->1</div><div>recent_release:<!-- --> <!-- -->1</div><div>not_brand_new:<!-- --> <!-- -->1</div><div>one_point_oh:<!-- --> <!-- -->0</div><div>dependent_projects:<!-- --> <!-- -->4</div><div>dependent_repositories:<!-- --> <!-- -->4</div><div>stars: <!-- -->3</div><div>contributors:<!-- --> <!-- -->1</div><div>subscribers:<!-- --> <!-- -->1</div><div>all_prereleases:<!-- --> <!-- -->0</div><div>any_outdated_dependencies:<!-- --> <!-- -->0</div><div>is_deprecated:<!-- --> <!-- -->0</div><div>is_unmaintained:<!-- --> <!-- -->0</div><div>is_removed: <!-- -->0</div></p></div></div></div></div><div class="row"><div class="col-md-12"></div></div></main></div></div></div></div><footer class="footer_footer__1tNtI"><div class="footer_footer-content__2FMz9"><div class="col-md-3"><div class="footer_footer-slogan__ppYfy"><h4>TrustSECO 2020</h4><p>A project by <a href="https://secureseco.org">SecureSECO</a></p></div></div><div class="col-md-3"><h4>Links</h4><ul><li><a href="https://github.com/SecureSECO/TrustSECO">Github</a></li><li><a href="https://twitter.com/SecoTrust">Twitter</a></li><li><a href="https://www.linkedin.com/company/trustseco">LinkeIn</a></li></ul></div><div class="col-md-3"></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"_id":"5fb667269f9e7f16fd3248e8","id":"emittery","crawlTimestamp":"19/11/2020 12:37:57","packageName":"emittery","description":"Simple and modern async event emitter","repository":{"type":"git","url":"git+https://github.com/sindresorhus/emittery.git"},"readme":"# \u003cimg src=\"media/header.png\" width=\"1000\"\u003e\n\n\u003e Simple and modern async event emitter\n\n[![Build Status](https://travis-ci.org/sindresorhus/emittery.svg?branch=master)](https://travis-ci.org/sindresorhus/emittery) [![codecov](https://codecov.io/gh/sindresorhus/emittery/branch/master/graph/badge.svg)](https://codecov.io/gh/sindresorhus/emittery) [![](https://badgen.net/bundlephobia/minzip/emittery)](https://bundlephobia.com/result?p=emittery)\n\nIt works in Node.js and the browser (using a bundler).\n\nEmitting events asynchronously is important for production code where you want the least amount of synchronous operations. Since JavaScript is single-threaded, no other code can run while doing synchronous operations. For Node.js, that means it will block other requests, defeating the strength of the platform, which is scalability through async. In the browser, a synchronous operation could potentially cause lags and block user interaction.\n\n## Install\n\n```\n$ npm install emittery\n```\n\n## Usage\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\n\nemitter.on('ğŸ¦„', data =\u003e {\n\tconsole.log(data);\n});\n\nconst myUnicorn = Symbol('ğŸ¦„');\n\nemitter.on(myUnicorn, data =\u003e {\n\tconsole.log(`Unicorns love ${data}`);\n});\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ'); // Will trigger printing 'ğŸŒˆ'\nemitter.emit(myUnicorn, 'ğŸ¦‹');  // Will trigger printing 'Unicorns love ğŸ¦‹'\n```\n\n## API\n\n### eventName\n\nEmittery accepts strings and symbols as event names.\n\nSymbol event names can be used to avoid name collisions when your classes are extended, especially for internal events.\n\n### emitter = new Emittery()\n\n#### on(eventName | eventName[], listener)\n\nSubscribe to one or more events.\n\nReturns an unsubscribe method.\n\nUsing the same listener multiple times for the same event will result in only one method call per emitted event.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\n\nemitter.on('ğŸ¦„', data =\u003e {\n\tconsole.log(data);\n});\nemitter.on(['ğŸ¦„', 'ğŸ¶'], data =\u003e {\n\tconsole.log(data);\n});\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ'); // log =\u003e 'ğŸŒˆ' x2\nemitter.emit('ğŸ¶', 'ğŸ–'); // log =\u003e 'ğŸ–'\n```\n\n##### Custom subscribable events\n\nEmittery exports some symbols which represent custom events that can be passed to `Emitter.on` and similar methods.\n\n- `Emittery.listenerAdded` - Fires when an event listener was added.\n- `Emittery.listenerRemoved` - Fires when an event listener was removed.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\n\nemitter.on(Emittery.listenerAdded, ({listener, eventName}) =\u003e {\n\tconsole.log(listener);\n\t//=\u003e data =\u003e {}\n\n\tconsole.log(eventName);\n\t//=\u003e 'ğŸ¦„'\n});\n\nemitter.on('ğŸ¦„', data =\u003e {\n\t// Handle data\n});\n```\n\n###### Listener data\n\n- `listener` - The listener that was added.\n- `eventName` - The name of the event that was added or removed if `.on()` or `.off()` was used, or `undefined` if `.onAny()` or `.offAny()` was used.\n\nOnly events that are not of this type are able to trigger these events.\n\n##### listener(data)\n\n#### off(eventName | eventName[], listener)\n\nRemove one or more event subscriptions.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\n\nconst listener = data =\u003e console.log(data);\n(async () =\u003e {\n\temitter.on(['ğŸ¦„', 'ğŸ¶', 'ğŸ¦Š'], listener);\n\tawait emitter.emit('ğŸ¦„', 'a');\n\tawait emitter.emit('ğŸ¶', 'b');\n\tawait emitter.emit('ğŸ¦Š', 'c');\n\temitter.off('ğŸ¦„', listener);\n\temitter.off(['ğŸ¶', 'ğŸ¦Š'], listener);\n\tawait emitter.emit('ğŸ¦„', 'a'); // nothing happens\n\tawait emitter.emit('ğŸ¶', 'b'); // nothing happens\n\tawait emitter.emit('ğŸ¦Š', 'c'); // nothing happens\n})();\n```\n\n##### listener(data)\n\n#### once(eventName | eventName[])\n\nSubscribe to one or more events only once. It will be unsubscribed after the first event.\n\nReturns a promise for the event data when `eventName` is emitted.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\n\nemitter.once('ğŸ¦„').then(data =\u003e {\n\tconsole.log(data);\n\t//=\u003e 'ğŸŒˆ'\n});\nemitter.once(['ğŸ¦„', 'ğŸ¶']).then(data =\u003e {\n\tconsole.log(data);\n});\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ'); // log =\u003e 'ğŸŒˆ' x2\nemitter.emit('ğŸ¶', 'ğŸ–'); // nothing happens\n```\n\n#### events(eventName)\n\nGet an async iterator which buffers data each time an event is emitted.\n\nCall `return()` on the iterator to remove the subscription.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\nconst iterator = emitter.events('ğŸ¦„');\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ1'); // Buffered\nemitter.emit('ğŸ¦„', 'ğŸŒˆ2'); // Buffered\n\niterator\n\t.next()\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value === 'ğŸŒˆ1'\n\t\treturn iterator.next();\n\t})\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value === 'ğŸŒˆ2'\n\t\t// Revoke subscription\n\t\treturn iterator.return();\n\t})\n\t.then(({done}) =\u003e {\n\t\t// done === true\n\t});\n```\n\nIn practice, you would usually consume the events using the [for await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) statement. In that case, to revoke the subscription simply break the loop.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\nconst iterator = emitter.events('ğŸ¦„');\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ1'); // Buffered\nemitter.emit('ğŸ¦„', 'ğŸŒˆ2'); // Buffered\n\n// In an async context.\nfor await (const data of iterator) {\n\tif (data === 'ğŸŒˆ2') {\n\t\tbreak; // Revoke the subscription when we see the value 'ğŸŒˆ2'.\n\t}\n}\n```\n\nIt accepts multiple event names.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\nconst iterator = emitter.events(['ğŸ¦„', 'ğŸ¦Š']);\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ1'); // Buffered\nemitter.emit('ğŸ¦Š', 'ğŸŒˆ2'); // Buffered\n\niterator\n\t.next()\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value === 'ğŸŒˆ1'\n\t\treturn iterator.next();\n\t})\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value === 'ğŸŒˆ2'\n\t\t// Revoke subscription\n\t\treturn iterator.return();\n\t})\n\t.then(({done}) =\u003e {\n\t\t// done === true\n\t});\n```\n\n#### emit(eventName, data?)\n\nTrigger an event asynchronously, optionally with some data. Listeners are called in the order they were added, but executed concurrently.\n\nReturns a promise that resolves when all the event listeners are done. *Done* meaning executed if synchronous or resolved when an async/promise-returning function. You usually wouldn't want to wait for this, but you could for example catch possible errors. If any of the listeners throw/reject, the returned promise will be rejected with the error, but the other listeners will not be affected.\n\n#### emitSerial(eventName, data?)\n\nSame as above, but it waits for each listener to resolve before triggering the next one. This can be useful if your events depend on each other. Although ideally they should not. Prefer `emit()` whenever possible.\n\nIf any of the listeners throw/reject, the returned promise will be rejected with the error and the remaining listeners will *not* be called.\n\n#### onAny(listener)\n\nSubscribe to be notified about any event.\n\nReturns a method to unsubscribe.\n\n##### listener(eventName, data)\n\n#### offAny(listener)\n\nRemove an `onAny` subscription.\n\n#### anyEvent()\n\nGet an async iterator which buffers a tuple of an event name and data each time an event is emitted.\n\nCall `return()` on the iterator to remove the subscription.\n\n```js\nconst Emittery = require('emittery');\n\nconst emitter = new Emittery();\nconst iterator = emitter.anyEvent();\n\nemitter.emit('ğŸ¦„', 'ğŸŒˆ1'); // Buffered\nemitter.emit('ğŸŒŸ', 'ğŸŒˆ2'); // Buffered\n\niterator.next()\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value is ['ğŸ¦„', 'ğŸŒˆ1']\n\t\treturn iterator.next();\n\t})\n\t.then(({value, done}) =\u003e {\n\t\t// done === false\n\t\t// value is ['ğŸŒŸ', 'ğŸŒˆ2']\n\t\t// Revoke subscription\n\t\treturn iterator.return();\n\t})\n\t.then(({done}) =\u003e {\n\t\t// done === true\n\t});\n```\n\nIn the same way as for `events`, you can subscribe by using the `for await` statement\n\n#### clearListeners(eventNames?)\n\nClear all event listeners on the instance.\n\nIf `eventNames` is given, only the listeners for that events are cleared.\n\n#### listenerCount(eventNames?)\n\nThe number of listeners for the `eventNames` or all events if not specified.\n\n#### bindMethods(target, methodNames?)\n\nBind the given `methodNames`, or all `Emittery` methods if `methodNames` is not defined, into the `target` object.\n\n```js\nimport Emittery = require('emittery');\n\nconst object = {};\n\nnew Emittery().bindMethods(object);\n\nobject.emit('event');\n```\n\n## TypeScript\n\nThe default `Emittery` class does not let you type allowed event names and their associated data. However, you can use `Emittery.Typed` with generics:\n\n```ts\nimport Emittery = require('emittery');\n\nconst emitter = new Emittery.Typed\u003c{value: string}, 'open' | 'close'\u003e();\n\nemitter.emit('open');\nemitter.emit('value', 'foo\\n');\nemitter.emit('value', 1); // TS compilation error\nemitter.emit('end'); // TS compilation error\n```\n\n### Emittery.mixin(emitteryPropertyName, methodNames?)\n\nA decorator which mixins `Emittery` as property `emitteryPropertyName` and `methodNames`, or all `Emittery` methods if `methodNames` is not defined, into the target class.\n\n```ts\nimport Emittery = require('emittery');\n\n@Emittery.mixin('emittery')\nclass MyClass {}\n\nconst instance = new MyClass();\n\ninstance.emit('event');\n```\n\n## Scheduling details\n\nListeners are not invoked for events emitted *before* the listener was added. Removing a listener will prevent that listener from being invoked, even if events are in the process of being (asynchronously!) emitted. This also applies to `.clearListeners()`, which removes all listeners. Listeners will be called in the order they were added. So-called *any* listeners are called *after* event-specific listeners.\n\nNote that when using `.emitSerial()`, a slow listener will delay invocation of subsequent listeners. It's possible for newer events to overtake older ones.\n\n## FAQ\n\n### How is this different than the built-in `EventEmitter` in Node.js?\n\nThere are many things to not like about `EventEmitter`: its huge API surface, synchronous event emitting, magic error event, flawed memory leak detection. Emittery has none of that.\n\n### Isn't `EventEmitter` synchronous for a reason?\n\nMostly backwards compatibility reasons. The Node.js team can't break the whole ecosystem.\n\nIt also allows silly code like this:\n\n```js\nlet unicorn = false;\n\nemitter.on('ğŸ¦„', () =\u003e {\n\tunicorn = true;\n});\n\nemitter.emit('ğŸ¦„');\n\nconsole.log(unicorn);\n//=\u003e true\n```\n\nBut I would argue doing that shows a deeper lack of Node.js and async comprehension and is not something we should optimize for. The benefit of async emitting is much greater.\n\n### Can you support multiple arguments for `emit()`?\n\nNo, just use [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment):\n\n```js\nemitter.on('ğŸ¦„', ([foo, bar]) =\u003e {\n\tconsole.log(foo, bar);\n});\n\nemitter.emit('ğŸ¦„', [foo, bar]);\n```\n\n## Related\n\n- [p-event](https://github.com/sindresorhus/p-event) - Promisify an event by waiting for it to be emitted\n","homepage":"https://github.com/sindresorhus/emittery#readme","trustScore":21,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":1,"not_brand_new":1,"one_point_oh":0,"dependent_projects":4,"dependent_repositories":4,"stars":3,"contributors":1,"subscribers":1,"all_prereleases":0,"any_outdated_dependencies":0,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":21},"versions":[{"versionNumber":"0.1.0","timestamp":"2017-11-27T21:18:15.608Z","trustScore":8,"dependencies":[]},{"versionNumber":"0.1.1","timestamp":"2017-11-28T18:36:40.282Z","trustScore":9,"dependencies":[]},{"versionNumber":"0.1.2","timestamp":"2017-11-29T09:56:39.280Z","trustScore":9,"dependencies":[]},{"versionNumber":"0.2.0","timestamp":"2017-11-29T19:27:07.743Z","trustScore":10,"dependencies":[]},{"versionNumber":"0.3.0","timestamp":"2018-02-15T16:14:22.395Z","trustScore":9,"dependencies":[]},{"versionNumber":"0.4.0","timestamp":"2018-06-07T13:11:18.841Z","trustScore":10,"dependencies":[]},{"versionNumber":"0.4.1","timestamp":"2018-07-12T16:24:06.729Z","trustScore":10,"dependencies":[]},{"versionNumber":"0.5.0","timestamp":"2019-09-17T14:25:38.742Z","trustScore":10,"dependencies":[]},{"versionNumber":"0.5.1","timestamp":"2019-09-26T17:20:12.779Z","trustScore":9,"dependencies":[]},{"versionNumber":"0.6.0","timestamp":"2020-03-09T08:27:05.774Z","trustScore":14,"dependencies":[]},{"versionNumber":"0.7.0","timestamp":"2020-05-11T14:16:35.566Z","trustScore":19,"dependencies":[]},{"versionNumber":"0.7.1","timestamp":"2020-07-05T13:53:56.828Z","trustScore":18,"dependencies":[]},{"versionNumber":"0.7.2","timestamp":"2020-10-17T00:06:22.486Z","trustScore":21,"dependencies":[]}]}},"__N_SSG":true},"page":"/package/[id]","query":{"id":"emittery"},"buildId":"9j_Ap2HDwE-BdC-I671C3","assetPrefix":"/TrustSECO","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"TrustSECO"}],["link",{"rel":"icon","href":"/favicon.ico"}]]}</script><script nomodule="" src="/TrustSECO/_next/static/chunks/polyfills-11c8eba6a84e3fddec04.js"></script><script src="/TrustSECO/_next/static/chunks/main-06c1dcca274dd3ebd367.js" async=""></script><script src="/TrustSECO/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/TrustSECO/_next/static/chunks/framework.490e6e89fb7343c23de5.js" async=""></script><script src="/TrustSECO/_next/static/chunks/commons.e12371422b04e39d225f.js" async=""></script><script src="/TrustSECO/_next/static/chunks/pages/_app-6332075865a73fbac0f6.js" async=""></script><script src="/TrustSECO/_next/static/chunks/20d867a918a78c19a392d2ab3562d7e5efc3a8e7.a2788434e14b577a5942.js" async=""></script><script src="/TrustSECO/_next/static/chunks/pages/package/%5Bid%5D-7bbdc45fafc792b9b77c.js" async=""></script><script src="/TrustSECO/_next/static/9j_Ap2HDwE-BdC-I671C3/_buildManifest.js" async=""></script><script src="/TrustSECO/_next/static/9j_Ap2HDwE-BdC-I671C3/_ssgManifest.js" async=""></script></body></html>