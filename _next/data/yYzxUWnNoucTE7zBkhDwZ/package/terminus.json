{"pageProps":{"postData":{"_id":"5fb66bb59f9e7f16fd324c81","id":"terminus","crawlTimestamp":"19/11/2020 12:57:23","packageName":"terminus","description":"An abstraction for making stream.Writable streams without all the boilerplate.","repository":{"type":"git","url":"git://github.com/brycebaril/node-terminus.git"},"readme":"terminus\n=====\n\n[![NPM](https://nodei.co/npm/terminus.png)](https://nodei.co/npm/terminus/)\n\n`terminus` makes it easier to create streams2 Writable streams. You can either use it like `through2` to eliminate subclassing boilerplate, or use one of the provided helper terminus streams.\n\n```javascript\nvar terminus = require(\"terminus\")\nvar through2 = require(\"through2\")\nvar spigot = require(\"stream-spigot\")\n\n// Streams2 all the way down...\n\nfunction uc(chunk, encoding, callback) {\n  this.push(chunk.toString().toUpperCase())\n  callback()\n}\n\nfunction log(chunk, encoding, callback) {\n  // This example is very contrived, you're likely better off directly piping to `process.stdout`\n  console.log(chunk.toString())\n  callback()\n}\n\nspigot([\"my \", \"dog \", \"has \", \"fleas\"])\n  .pipe(through2(uc))\n  .pipe(terminus(log))\n\n/*\nMY\nDOG\nHAS\nFLEAS\n*/\n\n// devnull\n\nvar spy = require(\"through2-spy\")\n\nspigot([\"my \", \"dog \", \"has \", \"fleas\"])\n  .pipe(spy({highWaterMark: 2}, function (buf) {console.log(buf.toString())}))\n  .pipe(terminus.devnull())\n\n/*\nmy\ndog\nhas\nfleas\n*/\n\n// concat\n\nfunction reverse(contents) {\n  console.log(contents.toString().split(\"\").reverse().join(\"\"))\n}\n\nspigot([\"my \", \"dog \", \"has \", \"fleas\"])\n  .pipe(terminus.concat(reverse))\n\n/*\nsaelf sah god ym\n*/\n\n// tail\n\nvar chunkLengths = []\nfunction logLength(chunk) {\n  chunkLengths.push(chunk.length)\n}\n\nvar ws = terminus.tail(logLength)\nws.on(\"finish\", function () {\n  console.log(chunkLengths)\n})\n\nspigot([\"my \", \"dog \", \"has \", \"fleas\"])\n  .pipe(ws)\n\n/*\n[ 3, 4, 4, 5 ]\n*/\n\n// objectMode\n\nvar s = spigot({objectMode: true}, [\n  {foo: 1},\n  {foo: 2},\n  {foo: 3},\n  {foo: 4},\n])\n\nfunction timesTwo(record, encoding, callback) {\n  record.foo *= 2\n  this.push(record)\n  callback()\n}\n\nfunction logRecords(records) {\n  console.log(records)\n}\n\ns.pipe(through2({objectMode: true}, timesTwo))\n .pipe(terminus.concat({objectMode: true}, logRecords))\n\n/*\n[ { foo: 2 }, { foo: 4 }, { foo: 6 }, { foo: 8 } ]\n*/\n```\n\nAPI\n===\n\n`terminus([options,] _writeFunction)`\n---\n\nCreate a `streams.Writable` instance that will call `_writeFunction` on every chunk. Consult the [stream.Writable](http://nodejs.org/api/stream.html#stream_class_stream_writable_1) documentation for instructions on creating a `_write` function.\n\n`terminus.ctor([options,] _writeFunction)`\n---\n\nCreate a `streams.Writable` Subclass that can be used to re-create stream.Writable instances with the same _writeFunction.\n\n`terminus.devnull([options])`\n---\n\nCreate a `stream.Writable` instance that is akin to writing to `dev/null` i.e. it doesn't do anything except give your stream somewhere to go.\n\nWhy? Because if your pipeline doesn't terminate on a Writable stream, it will get paused at the High Water Mark with nothing to unpause it. I've most often seen this when people are using PassThrough streams, or Transforms that incorporate all required behavior.\n\n`terminus.concat([options], fn)`\n---\n\nCollect the entire stream and when it is done, call `fn(contents)`. This is similar to the stream behavior of [concat-stream](http://npm.im/concat-stream) without the extra Array/Buffer concat behavior and entirely in streams2.\n\n`terminus.tail([options], fn)`\n---\n\nA slightly less complicated version of `terminus([options,] _writeFunction)` that only requries you to provide a function that operates as `fn(chunk, encoding)`.\n\noptions\n---\n\nAll functions accept standard `streams.Writable` options, that is:\n\n  * highWaterMark `[Number]` Buffer level when write() starts returning false. `Default=16kb`\n  * decodeStrings `[Boolean]` Whether not to decode strings into Buffers before passing them to _write() `Default=true`\n  * objectMode `[Boolean]` If the content is Javascript objects versus strings/buffers. `Default=false`\n\nobjectMode\n---\n\nThe most common option you'll be setting is `objectMode` which will enable you to stream Javascript objects, e.g. records. Unfortunately this is currently required and **ALL** streams2 parts of your stream pipeline must be in `objectMode` or you'll get errors. It's annoying, I know.\n\nLICENSE\n=======\n\nMIT\n","homepage":"https://github.com/brycebaril/node-terminus","trustScore":14,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":0,"not_brand_new":1,"one_point_oh":1,"dependent_projects":4,"dependent_repositories":2,"stars":1,"contributors":0,"subscribers":0,"all_prereleases":0,"any_outdated_dependencies":-1,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":14},"versions":[{"versionNumber":"1.0.0","timestamp":"2013-09-21T22:21:15.449Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"stream-spigot","version":"~2.1.1"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.0.6"}]},{"versionNumber":"1.0.1","timestamp":"2013-09-28T21:06:37.747Z","trustScore":7,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.0.6"}]},{"versionNumber":"1.0.2","timestamp":"2013-09-28T21:07:18.923Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.0.7"}]},{"versionNumber":"1.0.3","timestamp":"2013-10-16T18:13:30.651Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.1.0"}]},{"versionNumber":"1.0.4","timestamp":"2013-10-27T16:53:35.177Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.1.0"}]},{"versionNumber":"1.0.6","timestamp":"2013-12-18T05:01:37.420Z","trustScore":7,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"},{"packageName":"bops","version":"0.1.1"}]},{"versionNumber":"1.0.7","timestamp":"2013-12-18T23:57:02.420Z","trustScore":7,"dependencies":[{"packageName":"readable-stream","version":"~1.1.9"},{"packageName":"xtend","version":"~2.1.1"}]},{"versionNumber":"1.0.8","timestamp":"2014-01-10T18:01:49.966Z","trustScore":7,"dependencies":[{"packageName":"readable-stream","version":"~1.1.10"},{"packageName":"xtend","version":"~2.1.2"}]},{"versionNumber":"1.0.9","timestamp":"2014-01-30T22:31:05.937Z","trustScore":7,"dependencies":[{"packageName":"readable-stream","version":"~1.1.10"},{"packageName":"xtend","version":"~2.1.2"}]},{"versionNumber":"1.0.10","timestamp":"2014-06-04T17:48:00.792Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.0.27-1"},{"packageName":"xtend","version":"~3.0.0"}]},{"versionNumber":"1.0.11","timestamp":"2014-11-03T18:44:41.220Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.0.33"},{"packageName":"xtend","version":"~4.0.0"}]},{"versionNumber":"1.0.12","timestamp":"2015-06-09T02:19:59.973Z","trustScore":6,"dependencies":[{"packageName":"readable-stream","version":"~1.0.33"},{"packageName":"xtend","version":"~4.0.0"}]},{"versionNumber":"1.1.0","timestamp":"2015-11-23T20:57:45.929Z","trustScore":14,"dependencies":[{"packageName":"readable-stream","version":"~2.0.4"},{"packageName":"xtend","version":"~4.0.0"}]}]}},"__N_SSG":true}