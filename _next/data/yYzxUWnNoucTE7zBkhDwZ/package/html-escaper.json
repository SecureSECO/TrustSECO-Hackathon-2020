{"pageProps":{"postData":{"_id":"5fb66b0f9f9e7f16fd324c08","id":"html-escaper","crawlTimestamp":"19/11/2020 12:54:37","packageName":"html-escaper","description":"fast and safe way to escape and unescape &<>'\" chars","repository":{"type":"git","url":"git+https://github.com/WebReflection/html-escaper.git"},"readme":"# html-escaper [![Build Status](https://travis-ci.org/WebReflection/html-escaper.svg?branch=master)](https://travis-ci.org/WebReflection/html-escaper) [![Coverage Status](https://coveralls.io/repos/github/WebReflection/html-escaper/badge.svg?branch=master)](https://coveralls.io/github/WebReflection/html-escaper?branch=master)\nA simple module to escape/unescape common problematic entities.\n\n\n## V3 ESM Only Release\n\nThe version 3 of this module ditches entirely legacy browsers and _nodejs_ with broken loaders, such as `v13.0.0` and `v13.1.0`.\n\nAs the code is basically identical, simply stick with version 2 if you have any issue with this one ðŸ‘‹\n\n\n### How\nThis package is available in npm so `npm install html-escaper` is all you need to do, using eventually the global flag too.\n\nOnce the module is present\n```js\nimport {escape, unescape} from 'html-escaper';\n\nescape('string');\nunescape('escaped string');\n```\n\n\n### Why\nthere is basically one rule only: do not **ever** replace one char after another if you are transforming a string into another.\n\n```js\n// WARNING: THIS IS WRONG\n// if you are that kind of dev that does this\nfunction escape(s) {\n  return s.replace(/&/g, \"&amp;\")\n          .replace(/</g, \"&lt;\")\n          .replace(/>/g, \"&gt;\")\n          .replace(/'/g, \"&#39;\")\n          .replace(/\"/g, \"&quot;\");\n}\n\n// you might be the same dev that does this too\nfunction unescape(s) {\n  return s.replace(/&amp;/g, \"&\")\n          .replace(/&lt;/g, \"<\")\n          .replace(/&gt;/g, \">\")\n          .replace(/&#39;/g, \"'\")\n          .replace(/&quot;/g, '\"');\n}\n\n// guess what we have here ?\nunescape('&amp;lt;');\n\n// now guess this XSS too ...\nunescape('&amp;lt;script&amp;gt;alert(\"yo\")&amp;lt;/script&amp;gt;');\n\n\n```\n\nThe last example will produce `<script>alert(\"yo\")</script>` instead of the expected `&lt;script&gt;alert(\"yo\")&lt;/script&gt;`.\n\nNothing like this could possibly happen if we grab all chars at once and either ways.\nIt's just a fortunate case that after swapping `&` with `&amp;` no other replace will be affected, but it's not portable and universally a bad practice.\n\nGrab all chars at once, no excuses!\n\n\n\n**more details**\nAs somebody might think it's an `unescape` issue only, it's not. Being an anti-pattern with side effects works both ways.\n\nAs example, changing the order of the replacement in escaping would produce the unexpected:\n```js\nfunction escape(s) {\n  return s.replace(/</g, \"&lt;\")\n          .replace(/>/g, \"&gt;\")\n          .replace(/'/g, \"&#39;\")\n          .replace(/\"/g, \"&quot;\")\n          .replace(/&/g, \"&amp;\");\n}\n\nescape('<'); // &amp;lt; instead of &lt;\n```\nIf we do not want to code with the fear that the order wasn't perfect or that our order in either escaping or unescaping is different from the order another method or function used, if we understand the issue and we agree it's potentially a disaster prone approach, if we add the fact in this case creating 4 RegExp objects each time and invoking 4 times `.replace` trough the `String.prototype` is also potentially slower than creating one function only holding one object, or holding the function too, we should agree there is not absolutely any valid reason to keep proposing a char-by-char implementation.\n\nWe have proofs this approach can fail already so ... why should we risk? Just avoid and grab all chars at once or simply use this tiny utility.\n\n### Backtick\nInternt explorer < 9 has [some backtick issue](https://html5sec.org/#102)\n\nFor compatibility sake with common server-side HTML entities encoders and decoders, and in order to have the most reliable I/O, this little utility will NOT fix this IE < 9 problem.\n\nIt is also important to note that if we create valid HTML and we set attributes at runtime through this utility, backticks in strings cannot possibly affect attribute behaviors.\n\n```js\nvar img = new Image();\nimg.src = html.escape(\n  'x` `<script>alert(1)</script>\"` `'\n);\n// it won't cause problems even in IE < 9\n```\n\n**However**, if you use `innerHTML` and you target IE < 9 then [this **might** be a problem](https://github.com/nette/nette/issues/1496).\n\nAccordingly, if you need more chars and/or backticks to be escaped and unescaped, feel free to use alternatives like [lodash](https://github.com/lodash/lodash) or [he](https://www.npmjs.com/package/he)\n\nHere a bit more of [my POV](https://github.com/WebReflection/html-escaper/commit/52d554fc6e8583b6ffdd357967cf71962fc07cf6#commitcomment-10625122) and why I haven't implemented same thing alternatives did. Good news: those are alternatives ;-)","homepage":"https://github.com/WebReflection/html-escaper","trustScore":17,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":0,"not_brand_new":1,"one_point_oh":1,"dependent_projects":4,"dependent_repositories":2,"stars":2,"contributors":0,"subscribers":1,"all_prereleases":0,"any_outdated_dependencies":0,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":17},"versions":[{"versionNumber":"1.0.0","timestamp":"2015-04-08T09:55:12.173Z","trustScore":8,"dependencies":[]},{"versionNumber":"1.0.1","timestamp":"2017-06-06T20:18:48.324Z","trustScore":7,"dependencies":[]},{"versionNumber":"2.0.0","timestamp":"2019-07-25T21:30:21.044Z","trustScore":8,"dependencies":[]},{"versionNumber":"2.0.1","timestamp":"2020-03-21T12:47:45.877Z","trustScore":12,"dependencies":[]},{"versionNumber":"2.0.2","timestamp":"2020-03-27T13:29:45.414Z","trustScore":15,"dependencies":[]},{"versionNumber":"3.0.0","timestamp":"2020-03-27T13:47:22.157Z","trustScore":17,"dependencies":[]}]}},"__N_SSG":true}