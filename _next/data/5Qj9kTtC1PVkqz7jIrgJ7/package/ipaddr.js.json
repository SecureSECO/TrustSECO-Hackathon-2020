{"pageProps":{"postData":{"_id":"5fb66ac09f9e7f16fd324bcc","id":"ipaddr.js","crawlTimestamp":"19/11/2020 12:53:19","packageName":"ipaddr.js","description":"A library for manipulating IPv4 and IPv6 addresses in JavaScript.","repository":{"type":"git","url":"git://github.com/whitequark/ipaddr.js.git"},"readme":"# ipaddr.js â€” an IPv6 and IPv4 address manipulation library [![Build Status](https://travis-ci.org/whitequark/ipaddr.js.svg)](https://travis-ci.org/whitequark/ipaddr.js)\n\nipaddr.js is a small (1.9K minified and gzipped) library for manipulating\nIP addresses in JavaScript environments. It runs on both CommonJS runtimes\n(e.g. [nodejs]) and in a web browser.\n\nipaddr.js allows you to verify and parse string representation of an IP\naddress, match it against a CIDR range or range list, determine if it falls\ninto some reserved ranges (examples include loopback and private ranges),\nand convert between IPv4 and IPv4-mapped IPv6 addresses.\n\n[nodejs]: http://nodejs.org\n\n## Installation\n\n`npm install ipaddr.js`\n\nor\n\n`bower install ipaddr.js`\n\n## Older Node support\n\nUse 2.x release for nodejs versions 10+.\nUse the 1.x release for versions of nodejs older than 10.\n\n## API\n\nipaddr.js defines one object in the global scope: `ipaddr`. In CommonJS,\nit is exported from the module:\n\n```js\nconst ipaddr = require('ipaddr.js');\n```\n\nThe API consists of several global methods and two classes: ipaddr.IPv6 and ipaddr.IPv4.\n\n### Global methods\n\nThere are three global methods defined: `ipaddr.isValid`, `ipaddr.parse` and\n`ipaddr.process`. All of them receive a string as a single parameter.\n\nThe `ipaddr.isValid` method returns `true` if the address is a valid IPv4 or\nIPv6 address, and `false` otherwise. It does not throw any exceptions.\n\nThe `ipaddr.parse` method returns an object representing the IP address,\nor throws an `Error` if the passed string is not a valid representation of an\nIP address.\n\nThe `ipaddr.process` method works just like the `ipaddr.parse` one, but it\nautomatically converts IPv4-mapped IPv6 addresses to their IPv4 counterparts\nbefore returning. It is useful when you have a Node.js instance listening\non an IPv6 socket, and the `net.ivp6.bindv6only` sysctl parameter (or its\nequivalent on non-Linux OS) is set to 0. In this case, you can accept IPv4\nconnections on your IPv6-only socket, but the remote address will be mangled.\nUse `ipaddr.process` method to automatically demangle it.\n\n### Object representation\n\nParsing methods return an object which descends from `ipaddr.IPv6` or\n`ipaddr.IPv4`. These objects share some properties, but most of them differ.\n\n#### Shared properties\n\nOne can determine the type of address by calling `addr.kind()`. It will return\neither `\"ipv6\"` or `\"ipv4\"`.\n\nAn address can be converted back to its string representation with `addr.toString()`.\nNote that this method:\n * does not return the original string used to create the object (in fact, there is\n   no way of getting that string)\n * returns a compact representation (when it is applicable)\n\nA `match(range, bits)` method can be used to check if the address falls into a\ncertain CIDR range. Note that an address can be (obviously) matched only against an address of the same type.\n\nFor example:\n\n```js\nconst addr  = ipaddr.parse('2001:db8:1234::1');\nconst range = ipaddr.parse('2001:db8::');\n\naddr.match(range, 32); // => true\n```\n\nAlternatively, `match` can also be called as `match([range, bits])`. In this way, it can be used together with the `parseCIDR(string)` method, which parses an IP address together with a CIDR range.\n\nFor example:\n\n```js\nconst addr = ipaddr.parse('2001:db8:1234::1');\n\naddr.match(ipaddr.parseCIDR('2001:db8::/32')); // => true\n```\n\nA `range()` method returns one of predefined names for several special ranges defined by IP protocols. The exact names (and their respective CIDR ranges) can be looked up in the source: [IPv6 ranges] and [IPv4 ranges]. Some common ones include `\"unicast\"` (the default one) and `\"reserved\"`.\n\nYou can match against your own range list by using\n`ipaddr.subnetMatch(address, rangeList, defaultName)` method. It can work with a mix of IPv6 or IPv4 addresses, and accepts a name-to-subnet map as the range list. For example:\n\n```js\nconst rangeList = {\n  documentationOnly: [ ipaddr.parse('2001:db8::'), 32 ],\n  tunnelProviders: [\n    [ ipaddr.parse('2001:470::'), 32 ], // he.net\n    [ ipaddr.parse('2001:5c0::'), 32 ]  // freenet6\n  ]\n};\nipaddr.subnetMatch(ipaddr.parse('2001:470:8:66::1'), rangeList, 'unknown'); // => \"tunnelProviders\"\n```\n\nThe addresses can be converted to their byte representation with `toByteArray()`. (Actually, JavaScript mostly does not know about byte buffers. They are emulated with arrays of numbers, each in range of 0..255.)\n\n```js\nconst bytes = ipaddr.parse('2a00:1450:8007::68').toByteArray(); // ipv6.google.com\nbytes // => [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, <zeroes...>, 0x00, 0x68 ]\n```\n\nThe `ipaddr.IPv4` and `ipaddr.IPv6` objects have some methods defined, too. All of them have the same interface for both protocols, and are similar to global methods.\n\n`ipaddr.IPvX.isValid(string)` can be used to check if the string is a valid address for particular protocol, and `ipaddr.IPvX.parse(string)` is the error-throwing parser.\n\n`ipaddr.IPvX.isValid(string)` uses the same format for parsing as the POSIX `inet_ntoa` function, which accepts unusual formats like `0xc0.168.1.1` or `0x10000000`. The function `ipaddr.IPv4.isValidFourPartDecimal(string)` validates the IPv4 address and also ensures that it is written in four-part decimal format.\n\n[IPv6 ranges]: https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L186\n[IPv4 ranges]: https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L71\n\n#### IPv6 properties\n\nSometimes you will want to convert IPv6 not to a compact string representation (with the `::` substitution); the `toNormalizedString()` method will return an address where all zeroes are explicit.\n\nFor example:\n\n```js\nconst addr = ipaddr.parse('2001:0db8::0001');\naddr.toString(); // => '2001:db8::1'\naddr.toNormalizedString(); // => '2001:db8:0:0:0:0:0:1'\n```\n\nThe `isIPv4MappedAddress()` method will return `true` if this address is an IPv4-mapped\none, and `toIPv4Address()` will return an IPv4 object address.\n\nTo access the underlying binary representation of the address, use `addr.parts`.\n\n```js\nconst addr = ipaddr.parse('2001:db8:10::1234:DEAD');\naddr.parts // => [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]\n```\n\nA IPv6 zone index can be accessed via `addr.zoneId`:\n\n```js\nconst addr = ipaddr.parse('2001:db8::%eth0');\naddr.zoneId // => 'eth0'\n```\n\n#### IPv4 properties\n\n`toIPv4MappedAddress()` will return a corresponding IPv4-mapped IPv6 address.\n\nTo access the underlying representation of the address, use `addr.octets`.\n\n```js\nconst addr = ipaddr.parse('192.168.1.1');\naddr.octets // => [192, 168, 1, 1]\n```\n\n`prefixLengthFromSubnetMask()` will return a CIDR prefix length for a valid IPv4 netmask or\nnull if the netmask is not valid.\n\n```js\nipaddr.IPv4.parse('255.255.255.240').prefixLengthFromSubnetMask() == 28\nipaddr.IPv4.parse('255.192.164.0').prefixLengthFromSubnetMask()  == null\n```\n\n`subnetMaskFromPrefixLength()` will return an IPv4 netmask for a valid CIDR prefix length.\n\n```js\nipaddr.IPv4.subnetMaskFromPrefixLength(24) == '255.255.255.0'\nipaddr.IPv4.subnetMaskFromPrefixLength(29) == '255.255.255.248'\n```\n\n`broadcastAddressFromCIDR()` will return the broadcast address for a given IPv4 interface and netmask in CIDR notation.\n```js\nipaddr.IPv4.broadcastAddressFromCIDR('172.0.0.1/24') == '172.0.0.255'\n```\n`networkAddressFromCIDR()` will return the network address for a given IPv4 interface and netmask in CIDR notation.\n```js\nipaddr.IPv4.networkAddressFromCIDR('172.0.0.1/24') == '172.0.0.0'\n```\n\n#### Conversion\n\nIPv4 and IPv6 can be converted bidirectionally to and from network byte order (MSB) byte arrays.\n\nThe `fromByteArray()` method will take an array and create an appropriate IPv4 or IPv6 object\nif the input satisfies the requirements. For IPv4 it has to be an array of four 8-bit values,\nwhile for IPv6 it has to be an array of sixteen 8-bit values.\n\nFor example:\n```js\nconst addr = ipaddr.fromByteArray([0x7f, 0, 0, 1]);\naddr.toString(); // => '127.0.0.1'\n```\n\nor\n\n```js\nconst addr = ipaddr.fromByteArray([0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\naddr.toString(); // => '2001:db8::1'\n```\n\nBoth objects also offer a `toByteArray()` method, which returns an array in network byte order (MSB).\n\nFor example:\n```js\nconst addr = ipaddr.parse('127.0.0.1');\naddr.toByteArray(); // => [0x7f, 0, 0, 1]\n```\n\nor\n\n```js\nconst addr = ipaddr.parse('2001:db8::1');\naddr.toByteArray(); // => [0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\n```\n","homepage":"https://github.com/whitequark/ipaddr.js#readme","trustScore":27,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":1,"not_brand_new":1,"one_point_oh":1,"dependent_projects":6,"dependent_repositories":6,"stars":3,"contributors":1,"subscribers":2,"all_prereleases":0,"any_outdated_dependencies":0,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":27},"versions":[{"versionNumber":"0.1.0","timestamp":"2011-07-28T15:57:40.643Z","trustScore":11,"dependencies":[{"packageName":"coffee-script","version":">= 1.1.1"}]},{"versionNumber":"0.1.1","timestamp":"2011-07-30T16:00:04.710Z","trustScore":11,"dependencies":[{"packageName":"coffee-script","version":">= 1.1.1"}]},{"versionNumber":"0.1.2","timestamp":"2013-12-06T22:00:21.923Z","trustScore":14,"dependencies":[]},{"versionNumber":"0.1.3","timestamp":"2014-07-09T08:26:58.804Z","trustScore":10,"dependencies":[]},{"versionNumber":"0.1.4","timestamp":"2014-11-18T22:00:30.596Z","trustScore":13,"dependencies":[]},{"versionNumber":"0.1.5","timestamp":"2014-11-19T21:57:24.625Z","trustScore":14,"dependencies":[]},{"versionNumber":"0.1.6","timestamp":"2014-11-26T16:34:44.619Z","trustScore":12,"dependencies":[]},{"versionNumber":"0.1.7","timestamp":"2015-01-29T03:39:54.325Z","trustScore":11,"dependencies":[]},{"versionNumber":"0.1.8","timestamp":"2015-01-29T23:40:08.892Z","trustScore":11,"dependencies":[]},{"versionNumber":"0.1.9","timestamp":"2015-03-11T10:41:42.690Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.0.0","timestamp":"2015-04-07T21:16:34.839Z","trustScore":11,"dependencies":[]},{"versionNumber":"1.0.1","timestamp":"2015-04-08T17:00:18.304Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.0.3","timestamp":"2015-08-27T06:31:09.446Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.0.4","timestamp":"2015-11-07T05:46:23.340Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.0.5","timestamp":"2015-12-09T14:36:42.259Z","trustScore":13,"dependencies":[]},{"versionNumber":"1.1.0","timestamp":"2016-01-29T22:33:58.126Z","trustScore":13,"dependencies":[]},{"versionNumber":"1.1.1","timestamp":"2016-05-24T07:18:13.893Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.2.0","timestamp":"2016-07-08T09:52:20.241Z","trustScore":13,"dependencies":[]},{"versionNumber":"1.3.0","timestamp":"2017-03-15T02:28:53.138Z","trustScore":14,"dependencies":[]},{"versionNumber":"1.4.0","timestamp":"2017-06-22T20:48:02.394Z","trustScore":11,"dependencies":[]},{"versionNumber":"1.5.0","timestamp":"2017-08-21T14:12:21.041Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.5.1","timestamp":"2017-08-22T20:35:18.455Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.5.2","timestamp":"2017-08-24T03:47:42.297Z","trustScore":14,"dependencies":[]},{"versionNumber":"1.5.3","timestamp":"2017-10-12T15:44:50.448Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.5.4","timestamp":"2017-10-17T07:27:07.211Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.6.0","timestamp":"2018-02-06T05:40:56.969Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.7.0","timestamp":"2018-04-10T10:12:13.872Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.8.0","timestamp":"2018-07-10T03:28:15.831Z","trustScore":11,"dependencies":[]},{"versionNumber":"1.8.1","timestamp":"2018-07-31T15:31:21.138Z","trustScore":12,"dependencies":[]},{"versionNumber":"1.9.0","timestamp":"2019-02-10T07:51:21.736Z","trustScore":13,"dependencies":[]},{"versionNumber":"1.9.1","timestamp":"2019-07-17T02:28:19.618Z","trustScore":10,"dependencies":[]},{"versionNumber":"2.0.0","timestamp":"2020-08-17T04:50:33.629Z","trustScore":27,"dependencies":[]}]}},"__N_SSG":true}