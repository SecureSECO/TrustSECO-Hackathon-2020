{"pageProps":{"postData":{"_id":"5fb663fa9f9e7f16fd324662","id":"snapdragon-node","crawlTimestamp":"19/11/2020 12:24:25","packageName":"snapdragon-node","description":"Class for creating AST nodes.","repository":{"type":"git","url":"git+https://github.com/here-be/snapdragon-node.git"},"readme":"# snapdragon-node [![NPM version](https://img.shields.io/npm/v/snapdragon-node.svg?style=flat)](https://www.npmjs.com/package/snapdragon-node) [![NPM monthly downloads](https://img.shields.io/npm/dm/snapdragon-node.svg?style=flat)](https://npmjs.org/package/snapdragon-node) [![NPM total downloads](https://img.shields.io/npm/dt/snapdragon-node.svg?style=flat)](https://npmjs.org/package/snapdragon-node) [![Linux Build Status](https://img.shields.io/travis/here-be/snapdragon-node.svg?style=flat&label=Travis)](https://travis-ci.org/here-be/snapdragon-node)\n\n> Class for creating AST nodes.\n\nPlease consider following this project's author, [Jon Schlinkert](https://github.com/jonschlinkert), and consider starring the project to show your :heart: and support.\n\n## Install\n\nInstall with [npm](https://www.npmjs.com/):\n\n```sh\n$ npm install --save snapdragon-node\n```\n\n## Usage\n\n```js\nconst Node = require('snapdragon-node');\n// either pass on object with \"type\" and (optional) \"val\"\nconst node1 = new Node({type: 'star', val: '*'});\n// or pass \"val\" (first) and \"type\" (second) as string\nconst node2 = new Node('*', 'star');\n// both result in => Node { type: 'star', val: '*' }\n```\n\n## Snapdragon usage\n\nWith [snapdragon](https://github.com/here-be/snapdragon) v0.9.0 and higher, it's recommended that you use `this.node()` to create a new `Node` inside parser handlers (instead of doing `new Node()`).\n\n### Snapdragon ^1.0.0\n\nExample usage inside a [snapdragon](https://github.com/here-be/snapdragon) parser handler function.\n\n```js\nconst Node = require('snapdragon-node');\nconst Token = require('snapdragon-token');\n\n// create a new AST node\nconst node = new Node({ type: 'star', value: '*' });\n\n// convert a Lexer Token into an AST Node\nconst token = new Token({ type: 'star', value: '*' });\nconst node = new Node(token);\n```\n\n## Node objects\n\nAST Nodes are represented as `Node` objects that implement the following interface:\n\n```js\ninterface Node {\n  type: string;\n  value: string | undefined\n  nodes: array | undefined\n}\n```\n\n* `type` **{string}** - A string representing the node variant type. This property is often used for classifying the purpose or nature of the node, so that parsers or compilers can determine what to do with it.\n* `value` **{string|undefined}** (optional) - In general, value should only be a string when `node.nodes` is undefined. This is not reinforced, but is considered good practice. Use a different property name to store arbitrary strings on the node when `node.nodes` is an array.\n* `nodes` **{array|undefined}** (optional) - array of child nodes\n\nA number of useful methods and non-enumerable properties are also exposed for adding, finding and removing child nodes, etc.\n\nContinue reading the API documentation for more details.\n\n## Node API\n\n### [Node](index.js#L20)\n\nCreate a new AST `Node` with the given `type` and `value`, or an object to initialize with.\n\n**Params**\n\n* `type` **{object|string}**: Either an object to initialize with, or a string to be used as the `node.type`.\n* `value` **{string|boolean}**: If the first argument is a string, the second argument may be a string value to set on `node.value`.\n* `clone` **{boolean}**: When an object is passed as the first argument, pass true as the last argument to deep clone values before assigning them to the new node.\n* `returns` **{Object}**: node instance\n\n**Example**\n\n```js\nconsole.log(new Node({ type: 'star', value: '*' }));\nconsole.log(new Node('star', '*'));\n// both result in => Node { type: 'star', value: '*' }\n```\n\n### [.clone](index.js#L50)\n\nReturn a clone of the node. Values that are arrays or plain objects are deeply cloned.\n\n* `returns` **{Object}**: returns a clone of the node\n\n**Example**\n\n```js\nconst node = new Node({type: 'star', value: '*'});\nconsle.log(node.clone() !== node);\n//=> true\n```\n\n### [.stringify](index.js#L68)\n\nReturn a string created from `node.value` and/or recursively visiting over `node.nodes`.\n\n* `returns` **{String}**\n\n**Example**\n\n```js\nconst node = new Node({type: 'star', value: '*'});\nconsle.log(node.stringify());\n//=> '*'\n```\n\n### [.push](index.js#L88)\n\nPush a child node onto the `node.nodes` array.\n\n**Params**\n\n* `node` **{Object}**\n* `returns` **{Number}**: Returns the length of `node.nodes`, like `Array.push`\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nfoo.push(bar);\n```\n\n### [.unshift](index.js#L117)\n\nUnshift a child node onto `node.nodes`, and set `node` as the parent on `child.parent`.\n\n**Params**\n\n* `node` **{Object}**\n* `returns` **{Number}**: Returns the length of `node.nodes`\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nfoo.unshift(bar);\n```\n\n### [.pop](index.js#L151)\n\nPop a node from `node.nodes`.\n\n* `returns` **{Number}**: Returns the popped `node`\n\n**Example**\n\n```js\nconst node = new Node({type: 'foo'});\nnode.push(new Node({type: 'a'}));\nnode.push(new Node({type: 'b'}));\nnode.push(new Node({type: 'c'}));\nnode.push(new Node({type: 'd'}));\nconsole.log(node.nodes.length);\n//=> 4\nnode.pop();\nconsole.log(node.nodes.length);\n//=> 3\n```\n\n### [.shift](index.js#L178)\n\nShift a node from `node.nodes`.\n\n* `returns` **{Object}**: Returns the shifted `node`\n\n**Example**\n\n```js\nconst node = new Node({type: 'foo'});\nnode.push(new Node({type: 'a'}));\nnode.push(new Node({type: 'b'}));\nnode.push(new Node({type: 'c'}));\nnode.push(new Node({type: 'd'}));\nconsole.log(node.nodes.length);\n//=> 4\nnode.shift();\nconsole.log(node.nodes.length);\n//=> 3\n```\n\n### [.remove](index.js#L197)\n\nRemove `node` from `node.nodes`.\n\n**Params**\n\n* `node` **{Object}**\n* `returns` **{Object}**: Returns the removed node.\n\n**Example**\n\n```js\nnode.remove(childNode);\n```\n\n### [.find](index.js#L228)\n\nGet the first child node from `node.nodes` that matches the given `type`. If `type` is a number, the child node at that index is returned.\n\n**Params**\n\n* `type` **{String}**\n* `returns` **{Object}**: Returns a child node or undefined.\n\n**Example**\n\n```js\nconst child = node.find(1); //<= index of the node to get\nconst child = node.find('foo'); //<= node.type of a child node\nconst child = node.find(/^(foo|bar)$/); //<= regex to match node.type\nconst child = node.find(['foo', 'bar']); //<= array of node.type(s)\n```\n\n### [.has](index.js#L259)\n\nReturns true if `node.nodes` array contains the given `node`.\n\n**Params**\n\n* `type` **{String}**\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\ncosole.log(foo.has(bar)); // false\nfoo.push(bar);\ncosole.log(foo.has(bar)); // true\n```\n\n### [.hasType](index.js#L284)\n\nReturn true if the `node.nodes` has the given `type`.\n\n**Params**\n\n* `type` **{String}**\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nfoo.push(bar);\n\ncosole.log(foo.hasType('qux'));          // false\ncosole.log(foo.hasType(/^(qux|bar)$/));  // true\ncosole.log(foo.hasType(['qux', 'bar'])); // true\n```\n\n### [.isType](index.js#L303)\n\nReturn true if the node is the given `type`.\n\n**Params**\n\n* `type` **{String}**\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst node = new Node({type: 'bar'});\ncosole.log(node.isType('foo'));          // false\ncosole.log(node.isType(/^(foo|bar)$/));  // true\ncosole.log(node.isType(['foo', 'bar'])); // true\n```\n\n### [.isEmpty](index.js#L323)\n\nReturns true if `node.value` is an empty string, or `node.nodes` does not contain any non-empty text nodes.\n\n**Params**\n\n* `fn` **{Function}**: (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst node = new Node({type: 'text'});\nnode.isEmpty(); //=> true\nnode.value = 'foo';\nnode.isEmpty(); //=> false\n```\n\n### [.isInside](index.js#L342)\n\nReturns true if the node has an ancestor node of the given `type`\n\n**Params**\n\n* `type` **{String}**\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst box = new Node({type: 'box'});\nconst marble = new Node({type: 'marble'});\nbox.push(marble);\nmarble.isInside('box'); //=> true\n```\n\n### [.siblings](index.js#L365)\n\nGet the siblings array, or `null` if it doesn't exist.\n\n* `returns` **{Array}**\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nfoo.push(bar);\nfoo.push(baz);\n\nconsole.log(bar.siblings.length) // 2\nconsole.log(baz.siblings.length) // 2\n```\n\n### [.index](index.js#L393)\n\nCalculate the node's current index on `node.parent.nodes`, or `-1` if the node does not have a parent, or is not on `node.parent.nodes`.\n\n* `returns` **{Number}**\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nconst qux = new Node({type: 'qux'});\nfoo.push(bar);\nfoo.push(baz);\nfoo.unshift(qux);\n\nconsole.log(bar.index) // 1\nconsole.log(baz.index) // 2\nconsole.log(qux.index) // 0\n```\n\n### [.prev](index.js#L424)\n\nGet the previous node from the [siblings](#siblings) array or `null`.\n\n* `returns` **{Object}**\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nfoo.push(bar);\nfoo.push(baz);\n\nconsole.log(baz.prev.type) // 'bar'\n```\n\n### [.next](index.js#L453)\n\nGet the next element from the [siblings](#siblings) array, or `null` if a next node does not exist.\n\n* `returns` **{Object}**\n\n**Example**\n\n```js\nconst parent = new Node({type: 'root'});\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nparent.push(foo);\nparent.push(bar);\nparent.push(baz);\n\nconsole.log(foo.next.type) // 'bar'\nconsole.log(bar.next.type) // 'baz'\n```\n\n### [.first](index.js#L480)\n\nGet the first child node from `node.nodes`.\n\n* `returns` **{Object}**: The first node, or undefiend\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nconst qux = new Node({type: 'qux'});\nfoo.push(bar);\nfoo.push(baz);\nfoo.push(qux);\n\nconsole.log(foo.first.type) // 'bar'\n```\n\n### [.last](index.js#L504)\n\nGet the last child node from `node.nodes`.\n\n* `returns` **{Object}**: The last node, or undefiend\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nconst bar = new Node({type: 'bar'});\nconst baz = new Node({type: 'baz'});\nconst qux = new Node({type: 'qux'});\nfoo.push(bar);\nfoo.push(baz);\nfoo.push(qux);\n\nconsole.log(foo.last.type) // 'qux'\n```\n\n### [.depth](index.js#L525)\n\nGet the `node.depth`. The root node has a depth of 0. Add 1 to child nodes for each level of nesting.\n\n* `returns` **{Object}**: The last node, or undefiend\n\n**Example**\n\n```js\nconst foo = new Node({type: 'foo'});\nfoo.push(bar);\n\nconsole.log(foo.depth) // 1\nconsole.log(bar.depth) // 2\n```\n\n### [Node#isNode](index.js#L545)\n\nStatic method that returns true if the given value is a node.\n\n**Params**\n\n* `node` **{Object}**\n* `returns` **{Boolean}**\n\n**Example**\n\n```js\nconst Node = require('snapdragon-node');\nconst node = new Node({type: 'foo'});\nconsole.log(Node.isNode(node)); //=> true\nconsole.log(Node.isNode({})); //=> false\n```\n\n### Non-enumerable properties\n\n* `node.isNode` **{boolean}** - this value is set to `true` when a node is created. This can be useful in situationas as a fast alternative to using `instanceof Node` if you [need to determine](#nodeisnode) if a value is a `node` object.\n* `node.size` **{number}** - the number of child nodes that have been pushed or unshifted onto `node.nodes` using the node's API. This is useful for determining if nodes were added to `node.nodes` without using `node.push()` or `node.unshift()` (for example: `if (node.nodes && node.size !== node.nodes.length)`)\n* `node.parent` **{object}** (instance of Node)\n\n## Release history\n\nSee [the changelog](changelog.md).\n\n## About\n\n<details>\n<summary><strong>Contributing</strong></summary>\n\nPull requests and stars are always welcome. For bugs and feature requests, [please create an issue](../../issues/new).\n\nPlease read the [contributing guide](.github/contributing.md) for advice on opening issues, pull requests, and coding standards.\n\n</details>\n\n<details>\n<summary><strong>Running Tests</strong></summary>\n\nRunning and reviewing unit tests is a great way to get familiarized with a library and its API. You can install dependencies and run tests with the following command:\n\n```sh\n$ npm install && npm test\n```\n\n</details>\n\n<details>\n<summary><strong>Building docs</strong></summary>\n\n_(This project's readme.md is generated by [verb](https://github.com/verbose/verb-generate-readme), please don't edit the readme directly. Any changes to the readme must be made in the [.verb.md](.verb.md) readme template.)_\n\nTo generate the readme, run the following command:\n\n```sh\n$ npm install -g verbose/verb#dev verb-generate-readme && verb\n```\n\n</details>\n\n### Related projects\n\nYou might also be interested in these projects:\n\n* [breakdance](https://www.npmjs.com/package/breakdance): Breakdance is a node.js library for converting HTML to markdown. Highly pluggable, flexible and easy… [more](http://breakdance.io) | [homepage](http://breakdance.io \"Breakdance is a node.js library for converting HTML to markdown. Highly pluggable, flexible and easy to use. It's time for your markup to get down.\")\n* [snapdragon-capture](https://www.npmjs.com/package/snapdragon-capture): Snapdragon plugin that adds a capture method to the parser instance. | [homepage](https://github.com/jonschlinkert/snapdragon-capture \"Snapdragon plugin that adds a capture method to the parser instance.\")\n* [snapdragon-cheerio](https://www.npmjs.com/package/snapdragon-cheerio): Snapdragon plugin for converting a cheerio AST to a snapdragon AST. | [homepage](https://github.com/jonschlinkert/snapdragon-cheerio \"Snapdragon plugin for converting a cheerio AST to a snapdragon AST.\")\n* [snapdragon-util](https://www.npmjs.com/package/snapdragon-util): Utilities for the snapdragon parser/compiler. | [homepage](https://github.com/here-be/snapdragon-util \"Utilities for the snapdragon parser/compiler.\")\n* [snapdragon](https://www.npmjs.com/package/snapdragon): Easy-to-use plugin system for creating powerful, fast and versatile parsers and compilers, with built-in source-map… [more](https://github.com/here-be/snapdragon) | [homepage](https://github.com/here-be/snapdragon \"Easy-to-use plugin system for creating powerful, fast and versatile parsers and compilers, with built-in source-map support.\")\n\n### Author\n\n**Jon Schlinkert**\n\n* [GitHub Profile](https://github.com/jonschlinkert)\n* [Twitter Profile](https://twitter.com/jonschlinkert)\n* [LinkedIn Profile](https://linkedin.com/in/jonschlinkert)\n\n### License\n\nCopyright © 2018, [Jon Schlinkert](https://github.com/jonschlinkert).\nReleased under the [MIT License](LICENSE).\n\n***\n\n_This file was generated by [verb-generate-readme](https://github.com/verbose/verb-generate-readme), v0.8.0, on November 24, 2018._","homepage":"https://github.com/here-be/snapdragon-node","trustScore":21,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":0,"not_brand_new":1,"one_point_oh":1,"dependent_projects":4,"dependent_repositories":6,"stars":1,"contributors":0,"subscribers":2,"all_prereleases":0,"any_outdated_dependencies":0,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":21},"versions":[{"versionNumber":"0.1.0","timestamp":"2017-01-20T11:25:52.299Z","trustScore":10,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"}]},{"versionNumber":"0.2.0","timestamp":"2017-01-21T02:36:41.677Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"}]},{"versionNumber":"1.0.0","timestamp":"2017-01-21T09:53:00.497Z","trustScore":12,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"snapdragon-util","version":"^1.0.0"}]},{"versionNumber":"1.0.1","timestamp":"2017-01-21T10:47:12.141Z","trustScore":10,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"snapdragon-util","version":"^1.0.2"}]},{"versionNumber":"1.0.2","timestamp":"2017-01-21T11:37:13.705Z","trustScore":8,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"lazy-cache","version":"^2.0.2"},{"packageName":"snapdragon-util","version":"^1.0.2"}]},{"versionNumber":"1.0.3","timestamp":"2017-01-21T11:41:10.411Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"lazy-cache","version":"^2.0.2"},{"packageName":"snapdragon-util","version":"^1.0.2"}]},{"versionNumber":"1.0.5","timestamp":"2017-02-05T07:01:57.810Z","trustScore":10,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"lazy-cache","version":"^2.0.2"},{"packageName":"snapdragon-util","version":"^1.0.3"}]},{"versionNumber":"1.0.6","timestamp":"2017-02-15T18:56:31.127Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^0.2.5"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"lazy-cache","version":"^2.0.2"},{"packageName":"snapdragon-util","version":"^1.0.3"}]},{"versionNumber":"2.0.0","timestamp":"2017-05-01T12:09:05.870Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^1.0.0"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"snapdragon-util","version":"^3.0.0"}]},{"versionNumber":"2.0.1","timestamp":"2017-05-01T12:26:36.594Z","trustScore":10,"dependencies":[{"packageName":"define-property","version":"^1.0.0"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"snapdragon-util","version":"^3.0.0"}]},{"versionNumber":"2.1.0","timestamp":"2017-06-25T11:54:44.027Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^1.0.0"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"object-copy","version":"^1.0.0"},{"packageName":"snapdragon-util","version":"^3.0.1"}]},{"versionNumber":"2.1.1","timestamp":"2017-06-25T12:04:17.139Z","trustScore":9,"dependencies":[{"packageName":"define-property","version":"^1.0.0"},{"packageName":"isobject","version":"^3.0.0"},{"packageName":"snapdragon-util","version":"^3.0.1"}]},{"versionNumber":"3.0.0","timestamp":"2018-11-24T09:18:16.600Z","trustScore":21,"dependencies":[]}]}},"__N_SSG":true}