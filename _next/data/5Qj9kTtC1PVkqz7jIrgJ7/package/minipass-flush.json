{"pageProps":{"postData":{"_id":"5fb6669a9f9e7f16fd324880","id":"minipass-flush","crawlTimestamp":"19/11/2020 12:35:36","packageName":"minipass-flush","description":"A Minipass stream that calls a flush function before emitting 'end'","repository":{"type":"git","url":"git+https://github.com/isaacs/minipass-flush.git"},"readme":"# minipass-flush\n\nA Minipass stream that calls a flush function before emitting 'end'\n\n## USAGE\n\n```js\nconst Flush = require('minipass-flush')\ncons f = new Flush({\n  flush (cb) {\n    // call the cb when done, or return a promise\n    // the 'end' event will wait for it, along with\n    // close, finish, and prefinish.\n    // call the cb with an error, or return a rejecting\n    // promise to emit 'error' instead of doing the 'end'\n    return rerouteAllEncryptions().then(() => clearAllChannels())\n  },\n  // all other minipass options accepted as well\n})\n\nsomeDataSource.pipe(f).on('end', () => {\n  // proper flushing has been accomplished\n})\n\n// Or as a subclass implementing a 'flush' method:\nclass MyFlush extends Flush {\n  flush (cb) {\n    // old fashioned callback style!\n    rerouteAllEncryptions(er => {\n      if (er)\n        return cb(er)\n      clearAllChannels(er => {\n        if (er)\n          cb(er)\n        cb()\n      })\n    })\n  }\n}\n```\n\nThat's about it.\n\nIf your `flush` method doesn't have to do anything asynchronous, then it's\nbetter to call the callback right away in this tick, rather than returning\n`Promise.resolve()`, so that the `end` event can happen as soon as\npossible.\n","homepage":"https://github.com/isaacs/minipass-flush#readme","trustScore":15,"sourceRank":{"basic_info_present":1,"repository_present":1,"readme_present":1,"license_present":1,"versions_present":1,"follows_semver":1,"recent_release":0,"not_brand_new":1,"one_point_oh":1,"dependent_projects":2,"dependent_repositories":4,"stars":0,"contributors":0,"subscribers":1,"all_prereleases":0,"any_outdated_dependencies":0,"is_deprecated":0,"is_unmaintained":0,"is_removed":0,"trustScore":15},"versions":[{"versionNumber":"1.0.0","timestamp":"2019-09-15T23:29:09.908Z","trustScore":7,"dependencies":[{"packageName":"minipass","version":"^2.5.1"}]},{"versionNumber":"1.0.1","timestamp":"2019-09-15T23:33:13.881Z","trustScore":6,"dependencies":[{"packageName":"minipass","version":"^2.5.1"}]},{"versionNumber":"1.0.2","timestamp":"2019-09-16T22:20:38.803Z","trustScore":7,"dependencies":[{"packageName":"minipass","version":"^2.6.2"}]},{"versionNumber":"1.0.3","timestamp":"2019-09-17T01:25:55.922Z","trustScore":8,"dependencies":[{"packageName":"minipass","version":"^2.6.2"}]},{"versionNumber":"1.0.4","timestamp":"2019-09-18T16:08:24.970Z","trustScore":8,"dependencies":[{"packageName":"minipass","version":"^2.6.2"}]},{"versionNumber":"1.0.5","timestamp":"2019-09-30T20:54:48.902Z","trustScore":15,"dependencies":[{"packageName":"minipass","version":"^3.0.0"}]}]}},"__N_SSG":true}